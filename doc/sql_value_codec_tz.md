
# Техническое задание: модуль `fbpp::core::detail::sql_value_codec`

## 1. Назначение
Создать единый модуль низкоуровневых преобразований между бинарным буфером Firebird (`MessageMetadata`, offsets) и типами C++. Модуль должен обслуживать текущие упаковщики (`TuplePacker`, `TupleUnpacker`, `JsonPacker`, `JsonUnpacker`) и будущий `StructPacker`. Цель — устранить дублирование кода, централизовать логику масштабирования чисел, дат/времени, BLOB и обеспечить идентичное поведение во всех сценариях.

## 2. Область работ
- Исследование актуальных преобразований в `json_packer.hpp`, `json_unpacker.hpp`, `tuple_unpacker.hpp`, `type_adapter.hpp` и утилитах Firebird.
- Проектирование и разработка модуля `fbpp::core::detail::sql_value_codec` (заголовочный и при необходимости `.cpp` файл).
- Миграция вызовов из Tuple/Json пакеров на новый модуль.
- Подготовка вспомогательных тестовых сценариев (юнит или интеграционные тесты) для ключевых типов.
- Документация новых API.

## 3. Функциональные требования
1. Поддерживаемые операции:
   - Запись значения из C++ (включая `TypeAdapter`) в бинарный буфер (`write_sql_value`).
   - Чтение значения из буфера в C++ тип или промежуточное представление (`read_sql_value`).
2. Покрытие Firebird-типов: CHAR/VARCHAR, BOOLEAN, SMALLINT/INTEGER/BIGINT, NUMERIC/DECIMAL с scale, FLOAT/DOUBLE, DECFLOAT16/34, INT128, DATE/TIME/TIMESTAMP/TZ, BLOB (text/binary), GUID, дополнительные типы из `extended_types`.
3. Учет `FieldInfo` (offset, nullOffset, scale, length, subType) и взаимодействие с `Transaction` для BLOB.
4. Совместимость с `TypeAdapter`: если для типа есть адаптер, `sql_value_codec` должен принимать уже адаптированное значение (Firebird-эквивалент) и не нарушать текущих сценариев.
5. Обработка ошибок: на несовпадение типов/scale/nullable выбрасывать `FirebirdException` с описанием поля и ожидаемого типа.
6. API должен позволять JSON-пакеру формировать строковые значения там, где сейчас принято отдавать строки (например, DECIMAL, TIMESTAMP). Для этого требуются перегруженные интерфейсы или вспомогательные функции преобразования результата в строку.

## 4. Нефункциональные требования
- Не нарушить существующее поведение пакеров (бит-совместимость буфера, формат JSON-ответов).
- Код должен быть самодостаточным, иметь минимальные зависимости и располагаться в `fbpp::core::detail`.
- Поддержка C++17 (в соответствии с остальным проектом).
- Предусмотреть юнит-тесты (если инфраструктура позволяет) или сценарии проверки через существующие интеграционные тесты.

## 5. Архитектура модуля
### 5.1 Структура файлов
```
external/fbpp/include/fbpp/core/detail/sql_value_codec.hpp
external/fbpp/src/core/detail/sql_value_codec.cpp   // при необходимости
```

### 5.2 Публичные API (detail-уровень)
```cpp
namespace fbpp::core::detail {

struct SqlWriteContext {
    const FieldInfo& field;
    Transaction* transaction; // может быть nullptr
};

struct SqlReadContext {
    const FieldInfo& field;
    Transaction* transaction; // может быть nullptr
};

// Запись произвольного значения value (уже приведённого к Firebird-совместимому типу)
void write_sql_value(const SqlWriteContext& ctx,
                     const auto& value,
                     uint8_t* dataPtr);

// Чтение в Firebird-совместимый тип. Возвращает значение как статически выводимый тип.
template<typename T>
T read_sql_value(const SqlReadContext& ctx,
                 const uint8_t* dataPtr);

// Вспомогательные функции для JSON-пакера (см. раздел 6).
std::string read_sql_value_as_string(const SqlReadContext& ctx,
                                     const uint8_t* dataPtr);

} // namespace fbpp::core::detail
```
- `write_sql_value`/`read_sql_value` реализуют свитч по `ctx.field.type`.
- Для BLOB используется `transaction`.
- `read_sql_value` может иметь специализации или `if constexpr` для возврата нужного типа (например, `int16_t`, `int32_t`, `double`, `Timestamp`).

### 5.3 Обработка nullable
- Функции `write_sql_value` не трогают NULL-флаг — им управляет уровень выше (Tuple/Struct пакер).
- Для чтения предусмотрены варианты: вызывающий код проверяет `null_ptr`, а затем вызывает `read_sql_value`. Для JSON добавляется helper, возвращающий `nullptr`, если полю соответствует NULL.

### 5.4 Работа с TypeAdapter
- Перед вызовом `write_sql_value` вызывающий код обязан привести пользовательский тип к Firebird-совместимому (`TypeAdapter::to_firebird`), как и сейчас.
- `read_sql_value` возвращает Firebird-тип; адаптеры применяются после возврата (текущая модель TupleUnpacker сохраняется).

## 6. Интеграция с JSON-пакером
### 6.1 Текущая ситуация
- `JsonPacker` при записи во многие поля использует напрямую memcpy и специализированную логику.
- `JsonUnpacker` часто возвращает строку (например, NUMERIC со scale → строка), чтобы не терять точность в JSON.

### 6.2 План действий
1. `write_sql_value` пригоден напрямую: JSON-пакер предоставляет числовое/строковое значение, приводит его к нужному C++ типу (как сейчас) и передаёт в codec.
2. Для чтения следует сохранить возможность выводить строку. Предлагается два уровня:
   - `read_sql_value` возвращает точный Firebird-тип (например, `int64_t` + scale).
   - `JsonUnpacker` после вызова codec, при необходимости, преобразует результат в строку (`decimal_to_string_i64`, `encodeTimestampToIso` и т.д.). Эти функции либо переиспользуются из codec, либо codec предоставляет готовые helpers `read_sql_value_as_string`.
3. Для типов, которые и сейчас возвращают числовые JSON-значения (INTEGER, DOUBLE), `JsonUnpacker` может использовать `read_sql_value` и укладывать итог в JSON без дополнительной логики.
4. Таким образом, полный отказ от строк внутри JSON-пакера не требуется; codec возвращает базовые значения, а JSON слой решает, в каком формате отдавать клиенту.

## 7. Этапы реализации

1. **Инвентаризация**
   - Составить таблицу соответствия Firebird-типа → текущий код преобразования (файл/функция).
   - Определить, где требуется транзакция (BLOB), где задействованы `TypeAdapter`.

2. **Проектирование API**
   - Утвердить окончательные сигнатуры `write_sql_value`/`read_sql_value` и вспомогательных функций.
   - Определить структуру `SqlWriteContext`/`SqlReadContext` или аналог.

3. **Реализация `sql_value_codec`**
   - Вынести код из Json/tuple пакеров в новый модуль, провести рефакторинг для повторного использования.
   - Обеспечить покрытие всех типов, добавить статические проверки/комментарии для неподдерживаемых случаев.

4. **Миграция Tuple-пакеров**
   - Заменить низкоуровневые участки в `tuple_unpacker.hpp` и (при наличии) TuplePacker на вызовы codec.
   - Проверить работу с `TypeAdapter`, `std::optional`, BLOB и расширенными типами.

5. **Миграция JSON-пакеров**
   - Подключить codec в `json_packer.hpp`: использовать `write_sql_value`, минимально меняя существующую проверку типов JSON.
   - Подключить codec в `json_unpacker.hpp`: использовать `read_sql_value`/`read_sql_value_as_string` и оставить финальное преобразование в JSON (строка/число) в прежнем виде.

6. **Тестирование**
   - Добавить новые тесты или расширить текущие (INSERT/SELECT с различными типами, включая NULL, BLOB, числовые с scale, даты/время).
   - Провести ручную проверку на целевых базах, если автоматизация недоступна.

7. **Документация**
   - Описать новый модуль в архитектурных документах (добавить раздел в `doc/structure_pack.md` или отдельный файл).
   - Зафиксировать инструкции по добавлению новых типов (одно место в codec).

## 8. Критерии готовности
- Все существующие тесты проходят без регрессий.
- Новые тесты покрывают ключевые SQL-типы (минимум: VARCHAR, INTEGER, BIGINT с scale, DATE/TIMESTAMP, BLOB, BOOLEAN, DECFLOAT).
- Tuple и JSON пакеры полностью работают через `sql_value_codec` (без дублирующих веток).
- Документация обновлена.
- Код ревью подтверждает отсутствие функциональных изменений в старом поведении.

## 9. Ответы на вопрос «нужно ли менять JSON-преобразования в строки?»
- **Нет, обязательной замены нет.** JSON-слой по-прежнему может возвращать строки там, где сейчас это сделано для точности (NUMERIC с scale, даты/время).
- `sql_value_codec` обеспечивает *декодирование* в Firebird-совместимый тип + предоставляет утилиты для преобразования в строку.
- JSON-слой решает, отдавать ли результат как число, строку или объект, не нарушая клиентские контракты.

## 10. Зависимости и риски
- Возможные расхождения в форматах (например, trimming пробелов у CHAR, представление DECIMAL). Требуется обширное тестирование.
- Работа с BLOB требует транзакции; необходимо удостовериться, что контекст всегда доступен.
- Миграция должна проводиться поэтапно, чтобы проще отследить регрессии.

## 11. Предложения по инструментам
- Временная компиляция нового модуля без интеграции для статического анализа.
- Использование `static_assert` для проверки, что на новый модуль действительно завязаны Tuple/Json пакеры (например, запретить прямой доступ к старым функциям).

---

После завершения этого ТЗ можно переходить к реализации `StructPacker` на базе `sql_value_codec`, сократив объём повторяющегося кода и обеспечив единообразие поведения.
