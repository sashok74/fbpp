#pragma once

#include <gtest/gtest.h>
#include <memory>
#include <string>
#include <nlohmann/json.hpp>
#include <fstream>
#include <unistd.h>  // for getpid()
#include "fbpp/core/connection.hpp"
#include "fbpp/core/transaction.hpp"
#include "fbpp/core/exception.hpp"
#include "fbpp_util/logging.h"

namespace fbpp {
namespace test {

using json = nlohmann::json;
using namespace fbpp::core;

// Base class for all fbpp tests
class FbppTestBase : public ::testing::Test {
protected:
    static json loadTestConfig() {
        // Try multiple paths to find the config file
        std::vector<std::string> paths = {
            "../../config/test_config.json",  // From build/tests when running via ctest
            "../config/test_config.json",      // From build when running directly
            "config/test_config.json",         // From project root
            "./test_config.json"               // Current directory
        };
        
        std::ifstream config_file;
        for (const auto& path : paths) {
            config_file.open(path);
            if (config_file.is_open()) {
                break;
            }
        }
        
        if (!config_file.is_open()) {
            throw std::runtime_error("Cannot open test_config.json - tried multiple paths");
        }
        json config;
        config_file >> config;
        return config;
    }
    
    static ConnectionParams getConnectionParams(const json& db_config) {
        ConnectionParams params;
        params.database = db_config["server"].get<std::string>() + ":" + 
                         db_config["path"].get<std::string>();
        params.user = db_config["user"].get<std::string>();
        params.password = db_config["password"].get<std::string>();
        params.charset = db_config["charset"].get<std::string>();
        return params;
    }
    
    static void initLoggingFromConfig(const json& config) {
        // Initialize logging from config if it exists
        if (config.contains("logging")) {
            auto logging_config = config["logging"];
            std::string level = logging_config.value("level", "info");
            bool console = logging_config.value("console", true);
            bool file = logging_config.value("file", false);
            std::string file_path = logging_config.value("file_path", "logs/test.log");
            size_t max_size_mb = logging_config.value("rotate_max_size_mb", 5);
            size_t max_files = logging_config.value("rotate_max_files", 3);
            
            util::Logging::init(level, console, file, file_path, max_size_mb, max_files);
        } else {
            // Default logging if no config
            util::Logging::init("info", true, false);
        }
    }
};

// Test with persistent database (created once, reused across tests)
class PersistentDatabaseTest : public FbppTestBase {
protected:
    static void SetUpTestSuite() {
        auto config = loadTestConfig();
        initLoggingFromConfig(config);  // Initialize logging from config
        auto db_config = config["tests"]["persistent_db"];
        db_params_ = getConnectionParams(db_config);
        
        // Create database once if it doesn't exist
        if (!Connection::databaseExists(db_params_.database, db_params_)) {
            Connection::createDatabase(db_params_);
            
            // Create initial schema
            auto conn = std::make_unique<Connection>(db_params_);
            conn->ExecuteDDL(
                "CREATE TABLE test_data ("
                "    id INTEGER NOT NULL PRIMARY KEY,"
                "    name VARCHAR(100),"
                "    amount DOUBLE PRECISION,"
                "    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
                ")");
            
            conn->ExecuteDDL(
                "CREATE TABLE test_log ("
                "    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,"
                "    message VARCHAR(500),"
                "    logged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
                ")");
        }
    }
    
    static void TearDownTestSuite() {
        // Persistent database is not dropped
    }
    
    void SetUp() override {
        connection_ = std::make_unique<Connection>(db_params_);
    }
    
    void TearDown() override {
        connection_.reset();
    }
    
    std::unique_ptr<Connection> connection_;
    static ConnectionParams db_params_;
};

// Test with temporary database (recreated for each test)
class TempDatabaseTest : public FbppTestBase {
protected:
    void SetUp() override {
        auto config = loadTestConfig();
        initLoggingFromConfig(config);  // Initialize logging from config
        auto db_config = config["tests"]["temp_db"];
        db_params_ = getConnectionParams(db_config);
        
        // Add unique suffix to avoid conflicts
        
        auto pos = db_params_.database.rfind(".fdb");
        if (pos != std::string::npos) {
            db_params_.database.insert(pos, "_" + std::to_string(getpid()) + 
                                           "_" + std::to_string(test_counter_++));
        }
        
        // Drop if exists and create new
        Connection::dropDatabase(db_params_);
        Connection::createDatabase(db_params_);
        
        connection_ = std::make_unique<Connection>(db_params_);
        
        // Create test schema
        createTestSchema();
    }
    
    void TearDown() override {
        connection_.reset();
        
        // Drop temporary database
        try {
            Connection::dropDatabase(db_params_);
        } catch (...) {
            // Ignore errors during cleanup
        }
    }
    
    virtual void createTestSchema() {
        connection_->ExecuteDDL(
            "CREATE TABLE test_table ("
            "    id INTEGER NOT NULL PRIMARY KEY,"
            "    name VARCHAR(100),"
            "    amount DOUBLE PRECISION"
            ")");
    }
    
    std::unique_ptr<Connection> connection_;
    ConnectionParams db_params_;
    static int test_counter_;
};


} // namespace test
} // namespace fbpp